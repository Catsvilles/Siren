{"sc":"OSCFunc.trace(false);\n\ns.quit\n\n~puke.free;\n\n(\nvar winenv = Env([1, 0.1, 0], [0.01, 1], [8, -8]); \nz = Buffer.sendCollection(s, winenv.discretize, 1);\nNdef(\\puke,\n  {\n    DFM1.ar(GrainIn.ar(2, Impulse.kr(\\dens.kr(0.1)), 1,\n    FBSineC.ar(\\freq.kr(400),\n    \\im.kr(0.1),\n    \\fb.kr(3),\n    \\a.kr(1.1),\n    \\c.kr(0.5),\n    \\xi.kr(0.1),\n    \\yi.kr(0.1)),0, z), \\cutoff.kr(0),\\res.kr(0.99))\n\n\n}).play;\n)\n","tidal":"hush\nd7 $ silence\nd6 $ silence\ncps 1\nd3 $ silence\nd4 $ silence\nd5 $ silence\nlet slicepat :: Pattern Int -> Int -> Pattern a -> Pattern a\n    slicepat pi n p = Pattern f\n    -- TODO deal with span vs span'\n      where f a = concatMap (\\(span, span', i) -> arc (compressTo span (zoomTo i p)) span) $ arc pi a\n            zoomTo :: Int -> Pattern a -> Pattern a\n            zoomTo i p = zoom ((fromIntegral (i `mod` n)) / fromIntegral n,\n                               (fromIntegral ((i `mod` n)+1)) / fromIntegral n\n                              ) p\n\nlet modNote n f p = stack [f $ filterValues (isEq n . (Map.!?n_p)) p,filterValues (not . isEq n . (Map.!?n_p)) p] where isEq a m = (isJust m) && (a == (fromJust $ fromV $ fromJust m))\n\n\n\nd1 $ nToOrbit $ modNote 1 ((#speed (scale 0.8 1.2 $ saw)).(#rect 0.5).(#comb (disc 4 $ scale 0.1 0.4 $ saw *rand)) )$slow (3.5/3) $ n \"{0 < ~ ~ 0 ~> <1 1 [~ 1] 1 1/2 [1 1] [~ 1 ]> 0 <1 1 1 [1 1]> ~ }%5 \" #s \"blp2\" #shape 0.5\n\nd1$ nToOrbit $ modNote 1 ((#end (disc 8 $ scale 0.8 1 $ saw)).(#sparkle 0.5).(#hall (disc 4 $ scale 0.001 0.1 $ saw *rand)) )$slow (2) $ n \"{0  1 <0 ~> <[~ 1 ]> 0 0 <1 [~ <1 1/2 1>]> }%8\" #s \"mp2\" #shape 0.5\n\nd2$ slow (3.5/3) $ struct \"{0 < ~ ~ 0 ~> <1 1 [~ 1] 1 1/2 [1 1] [~ 1 ]> 0 <1 1 1 [1 1]> ~}%5 \"$ note (scaleP \"dorian\" \"{c4 [gs4 c5] ~  g3 ~ }%5\") #s \"nord\" #sustain 0.2 #gain \"<0.9 1.1>\"\n\nd3 $ slow 2 $note (scaleP\"dorian\"\"{<0 0 1> ~ ~ ~ ~ ~}%5\") #sound \"chord1\" #orbit 5 #sustain 8 #hall 0.12 #gain 1.2 #speed 1 #lpf 5000\n\n\n\n\n\n\n"}
